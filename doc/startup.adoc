= Startup

This document describes how Hubris takes a CPU from reset to running your
application. It is mostly architecture-neutral; any architecture-specific bits
will be called out.

== From reset to Rust

At reset, the processor runs a designated chunk of code, the *reset handler.*
Hubris's reset handler is responsible for making the world safe for Rust code.
This means:

- Setting up a stack pointer, if the hardware doesn't do that for us;

- Enabling any processor features or memory devices required to run the kernel
  -- for example, if the device has an FPU, we need it turned on so we can
  configure it even though the kernel itself may not use floating point;

- Ensuring that all initialized variables get initialized;

- Jumping to `main`.

On ARMv7-M this sequence is handled by the `cortex_m_rt` crate, which in turn
uses the `r0` crate to set up Rust variables.

=== `main`: bring your own

Currently, Hubris expects the application packager (i.e. you) to provide a
`main` routine in the crate that builds the kernel. This gives you an
opportunity to do any setup that isn't handled by the runtime startup, but needs
to happen before the kernel boots.

`main` should do those things, and then call `start_kernel`.

In the same file, you will typically need to declare interrupt service routines
for any SoC-specific interrupts that you wish to handle. These ISRs should
simply invoke Hubris's generic interrupt posting routine (TBD).

=== Starting the kernel

The kernel expects to be packaged in Flash with a table describing the tasks.
This table would normally immediately follow the kernel image, though it can be
placed anywhere; the kernel finds it using the `hubris_app_descriptor` symbol.

The table consists of the following:

- An `App` header record describing the overall shape of things to come.
- One or more region descriptor (`RegionDesc`) records, carving up address space
  into regions with attributes.
- One or more task descriptor (`TaskDesc`) records describing tasks.

The `App` header gives the size of both of the following tables. See
`kern/src/app.rs` for details and layout.

TIP: Region descriptors can be shared among tasks -- task descriptors specify
the regions they can access by _index_. Task descriptors contain the initial
program counter and stack pointer values for the task, which will be loaded into
those registers when the task first runs (or is restarted). Hubris will check
that those pointers fall within some memory region, but other than that, the
layout of your task memory regions and their roles is totally up to you.

`start_kernel` reads the `App` header and the task and region descriptors,
validates their integrity, and allocates RAM. This is the only time the kernel
allocates RAM, and it allocates it from a single contiguous area delimited by
the `hubris_kernel_ram_start` and `hubris_kernel_ram_end` symbols. (This area of
memory should not overlap any of your application memory regions.)

In this memory area, the kernel allocates bookkeeping information for each task
described in the task table. The few kernel global variables are *not* placed
here; it's only used for stuff that is dynamically sized based on information
found in the `App` header.

If the kernel cannot allocate bookkeeping structures for the tasks described in
the descriptor tables, it will panic.

Any extra RAM allocated to the kernel, but not used, is lost.

=== Starting the first task(s)

One of the fields in the task descriptor contains a `START_AT_BOOT` flag. Any
task with this flag set will be initialized in `Runnable` state; all others are
initialized in `Stopped` state.

As its last act during startup, the kernel scans the tasks looking for the
*highest priority* task marked `START_AT_BOOT`. It then switches into that task,
and your application is running.

If the task descriptor table contains *zero* tasks marked `START_AT_BOOT`, this
represents an application configuration error, and the kernel will panic.

=== Example

Consider the following device which does not exist:

```
High address    +-------------------------------------+<----+ Peripherals end
                |     Device3 Registers (RW, device)  |
                |                                     |
                |                                     |
 0x40002000 +-> +-------------------------------------+
                |     Device2 Registers (RW, device)  |
                |                                     |
                |                                     |
 0x40001000 +-> +-------------------------------------+
                |     Device1 Registers (RW, device)  |
                |                                     |
 0x40000000 +-> +--------------------------------------<----+ Peripherals Start
                |     Empty address space             |
                +--------------------------------------<----+ RAM end
                |     Task2 .data (RW)                |
                |                                     |
    0x21000 +-> +-------------------------------------+
                |     Task2 stack (RW)                |
                |                                     |
    0x20000 +-> +-------------------------------------+
                |     Task1 .data (RW)                |
                |                                     |
    0x12000 +-> +-------------------------------------+
                |     Task1 Stack (RW)                |
                |                                     |
    0x11000 +-> +--------------------------------------<---+ hubris_kernel_ram_end
                |     Kernel RAM                      |
                |                                     |
    0x10000 +-> +--------------------------------------<----+ RAM start/hubris_kernel_ram_start
                |     Empty address space             |
     0x3000 +-> +--------------------------------------<----+ Flash end
                |     Task2 .rodata (RO)              |
                |                                     |
                +-------------------------------------+
                |     Task2 .text (RO)                |
                |                                     |
     0x2000 +-> +-------------------------------------+
                |     Task1 .rodata (RO)              |
                |                                     |
                +-------------------------------------+
                |     Task1 .text (RO)                |
                |                                     |
     0x1000 +-> +-------------------------------------+
                |     Vectors                         |
 Low address    +-------------------------------------v<-----+Flash start


```

Suppose that Task1 needs access to Device1 and Device3 and Task2 needs
access to Device2 and Device3. The descriptors would look like:

```
App {
	magic: kernel::app::CURRENT_APP_MAGIC,
	region_count:
	task_count: 2,
	zeroed_expansion_space: [0; 16],
}
TaskDesc {
	entry_point: 0x1000
	flags: TaskFlags::START_AT_BOOT,
	initial_stack: 0x12000
	regions: [1, 2, 5, 7, 0, 0, 0, 0]
}
TaskDesc {
	entry_point: 0x2000
	flags: TaskFlags::START_AT_BOOT,
	initial_stack: 0x21000,
	regions: [3, 4, 6, 7, 0, 0, 0, 0]
}

# The empty region
RegionDesc {
	base: 0
	size: !0
	attributes: RegionAttributes::RW
	reserved_zero: 0
}

# Task 1 Read Only
RegionDesc {
	base: 0x1000
	size: 0x1000
	attributes: RegionAttributes::RO
	reserved_zero: 0
}
# Task 1 Read Write
RegionDesc  {
	base: 0x11000
	size: 0x2000
	attributes: RegionAttributes::RW
	reserved_zero: 0
}
# Task 2 Read Only
RegionDesc {
	base: 0x2000
	size: 0x1000
	attributes: RegionAttributes::RO
	reserved_zero: 0
}
# Task 2 Read Write
RegionDesc {
	base: 0x20040
	size: 0x40
	attributes: RegionAttributes::RW
	reserved_zero: 0
}
# Device 1
RegionDesc {
	base: 0x40000000
	size: 0x1000
	attributes: RegionAttributes::Device | RegionAttributes::RW
	reserved_zero: 0
}
# Device 2
RegionDesc  {
	base: 0x40001000
	size: 0x1000
	attributes: RegionAttributes::Device | RegionAttributes::RW
	reserved_zero: 0
}
# Device 3
RegionDesc  {
	base: 0x40002000
	size: 0x1000
	attributes: RegionAttributes::Device | RegionAttributes::RW
	reserved_zero: 0
}
```
